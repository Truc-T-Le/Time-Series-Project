---
title: "Time Series FInal Project"
author: "Truc Le"
date: "3/8/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
source("https://raw.githubusercontent.com/Truc-T-Le/Time-Series-Project/main/trndseas.R")
chicago <- read.csv("https://raw.githubusercontent.com/Truc-T-Le/Time-Series-Project/main/chicago.csv")
library("forecast")
```

#I Introduction

  The goal of this report is to fit a time series model to the Chicago dataset in order to predict the daily average reciepts per theatres for the movie Chicago for the given four and a half months time period. The dataset contains the daily average reciepts per theatres for the movie Chicago from January 3, 2003 up until April 18, 2003, and it is considered a time series since the data was taken over a period of time within equaled spaced increments. Time series modeling is important for this dataset as it can forecast the data points outside of the given time intervals by using model it already created from the current data points it possess. However, there are constraints to this time series prediction model, it is illogical to forecast before the movie was released and after it is no longer in theatre as it would give inaccurate predictions for the daily average reciepts per theatres. In addition, like any time series model, it should be noted that any forecasting farther away from the given model would have a higher probability of incurracy in predicting the daily average reciepts per theatres for the movie Chicago.  


# II. Materials and Methods: Description of the Data and Methods Used in the Analysis

For this project, we were provided a file (`Chicago.txt`), which contains daily average receipts (`Receipts`) per theater for the movie Chicago. The data covers the time period January 3, 2003 to April 23, 2003 (time $t = 1,...,106$). 

A simple plot of `Receipts` against `t`:

```{r, echo=FALSE}
y <- chicago$reciepts
t <- 1:106
plot(t, y, type = "l", ylab = "Receipts", main = "Plot of Receipts against t")
```

From the `Plot of Receipts against t`, it is observed that `Receipts` seems to have trend, seasonal, and rough components, with a cycle of rougly 7 days. A noticeable problem observed from the above plot is that the spread of `Receipts` changes over time (i.e. the variance is not constant). To address this problem, a Box-Cox transformation will be apply to the dataset, which will make the spread of `Receipts` more constant overtime. 

To fit a time-series model to the dataset, we will use the basic model of $Y_t = m_t + s_t + X_t, \ t = 1,...,n = 106$, where $Y_t$ denotes `Receipts`, $m_t$ denotes the trend, $s_t$ denotes the seasonal component, and $X_t$ denotes the rough part. To estimate $m_t$ and $s_t$, the function `trndseas()`, which was provided in the file `trndseas.R`, will be used. After obtaining the $\hat{m}_t$ and $\hat{s}_t$ (the estimated trend and seasonal effects respectively),the rough part is then estimated by subtracting the estimated trend and seasonal effects from the observed values (i.e. $\hat{X}_t = Y_t - \hat{m}_t - \hat{s}_t$). After obtaining the estimated rough, the `auto.arima()` function will be used to find the best ARMA model. This ARMA model will then be used to estimate the rough in the time-series prediction model. 


```{r, echo=FALSE}
trndseas=function(y,seas,lam,degtrnd){

    
# requires the R-package 'pracma'
  
# fits  a trend plus seasonal for the "best" Box-Cox 
# transformation.
  
# input: y, observed series; seas, seasons
  
# input: lam, the grid of Box-Cox transformations (lambda values)
  
# input: degtrnd, degree of the polynomial trend, if
# degtrnd=0, then the fitted trend is constant.
  
# output:  coef, regression coefficients - the
# first degtrnd+1 values for the trend part and the
# rest associated with the seasonals
  
# output: fit, fitted y-values; res, residuals,
  
# output: trend, fitted trend; season, fitted seasonals
  
# output: rsq, adjusted r-square values for different lambda in the
  
# output: lamopt, the value of lambda (among those supplied 
# in the vector lam) at which r-square is maximum.

m=length(lam)
n=length(y)

# Part of design matrix for estimating trend
if(degtrnd>0) {
   tm=seq(1/n,1,by=1/n)
   x1=poly(tm,degree=degtrnd,raw=TRUE)
   x1=cbind(rep(1,n),x1)
   } else {
    x1=as.matrix(rep(1,n),ncol=1)
   }

# Part of design matrix for estimating seasonality
x2=NULL
if(seas>1){
sn=rep(1:seas,length.out=n)
x2=factor(sn,levels=unique(sn),ordered=TRUE)
x2=model.matrix(~x2-1)
m2=ncol(x2)
m21=m2-1
x2=x2[,1:m21]-matrix(rep(x2[,m2],m21),ncol=m21,nrow=nrow(x2),byrow=F)
}

x=cbind(x1,x2)  # design matrix

xx=t(x)%*%x
rsq=rep(1,m)
m1=ncol(x1)     #degtrnd+1
m11=m1+1
mx=ncol(x)      # degtrnd+1+seas-1

for(i in 1:m) {
  if (lam[i]==0) {
    yt=log(y)
  } else {
    yt=y^lam[i]
   }
  xy=t(x)%*%yt
  coef=solve(xx,xy)
  fit=x%*%coef
  res=yt-fit
  ssto=(n-1)*var(yt)
  sse=t(res)%*%res
  rsq[i]=1-((n-1)/(n-mx))*sse/ssto
  }

  ii=which.max(rsq)
  lamopt=lam[ii]
  if (lamopt==0) {
    yt=log(y)
  } else {
    yt=y^lamopt
   }
  xy=t(x)%*%yt
  coef=solve(xx,xy)
  fit=x%*%coef
  trnd=x1%*%coef[1:m1]
  season=NULL
  if(seas>1){
  season=c(coef[m11:mx],-sum(coef[m11:mx]))
  }
  res=yt-fit

  result=list(coef=coef,fitted=fit,trend=trnd,residual=res,season=season,rsq=rsq,lamopt=lamopt)
  return(result)
}
  
```

# III. Results: Explanation of the Results in our Analysis
```{r, echo=FALSE}
#3/4/5
y<-  chicago$reciepts
tm<- 1:106
seas <- 7
lam=seq(-1,1,by=0.05)
ff=trndseas(chicago$reciepts,seas,lam,3)
rsq=ff$rsq
ff=trndseas(chicago$reciepts,seas,0.1,3)
trend=ff$trend
season=ff$season
fit=ff$fit
Day=1:7
```

```{r, echo=FALSE}
plot(lam,rsq,type="l",xlab="Lambda",ylab="R-sq",main="Average Ticket sales: R-square")
```

As previously discussed, due to the inconsistent variance observed from the `Plot of Receipts against t`, it is necessary to perform a Box-Cox transformation on the original data before a time series model could be fitted. In order to choose an appropiate Box-Cox transformation, the optimal lambda must be picked first. When picking for the optimal lambda, the 

```{r, echo=FALSE}


#fitted 
{plot.ts(y^0.1,ylab="",main='Plot: y^0.1,fit')
points(tm,fit,type='l',lty=2, col="red")
legend(175,0.070, c("data","fit"), lty=c(1,1,2))}

#trend line 
{plot.ts(y^0.1,ylab="",main='Plot: y^0.1, trend')
points(tm,trend,type='l', col="purple")
legend(175,0.070, c("data","trend"), lty=c(1,1,2))}

plot(Day,season,type='l',ylab='Seasonals',main='Seasonals for 1/y^0.1')


#transformed
{
lny <-(y)^0.1
plot(tm, lny, type = "l", lty = 1, xlab = "Time", ylab = "power of 0.1 daily average reciepts per theatre",main = "power of 0.1 daily average reciepts per theatre versus time")
points(tm, fit, type = "l", lty = 2, col = "blue")
legend("topleft", "fitted values", lty = 2, col = "blue")
}


plot(lny-fit, type = "l", xlab = "Time", ylab = "Residuals", main = "Rough part")


#6 
acf(lny-fit) 
pacf(lny-fit)

#7
a<-auto.arima(lny-fit, stepwise = F, approximation = F, trace= TRUE, ic = "aicc", max.order = 10)

mod_ARMA<- arima(y^0.1-fit, order =c(1,0,1))
mod_ARMA$coef
mod_ARMA$var.coef
mod_ARMA$sigma2
res <- mod_ARMA$residuals
ts.plot(res)

acf(res)
hist(res)

qqnorm(res);qqline(res)


#8

specselect=function(y,kmax)
  {
  ii=spec.pgram(y,log="no",plot=FALSE)
  ii=ii$spec
  cc=norm(as.matrix(ii),type="F")^2
  ctr=rep(1,kmax) ###criterion function
  for(k in 1:kmax) 
    {
    ss=2*k+1; kk=1/(2*k)
    ff=spec.pgram(y,spans=ss,log="no",plot=FALSE)
    fspec=ff$spec
    ctr[k]=norm(as.matrix(ii-fspec),type="F")^2+kk*cc
  }
  kopt=which.min(ctr)
  result=list(ctr=ctr,kopt=kopt)
  return(result)
}

specselect(lny-fit,18)


library(astsa)
coef.ar <- mod_ARMA$coef[1]
coef.ma <- mod_ARMA$coef[2]
sigma2 <- mod_ARMA$sigma2
mod_spec <-arma.spec(ar=coef.ar, ma=coef.ma, var.noise=sigma2, log='no')
plot(mod_spec$freq, mod_spec$spec, type='l', xlab='Frequency', ylab='')


#8.a
{arma.spec(ar=coef.ar, ma=coef.ma,var.noise = sigma2, log = "no",main="Spectral Density and Smooth Periodogram")
smooth<-spec.pgram(lny-fit, log = "no", spans = 11, main="", xlab="", ylab="", plot=F )
lines(smooth$freq, smooth$spec, col = "green")
legend(0.3, 0.018, legend = c("Spectral", "Smoothed"), col = c("black", "green"), lty = 1, cex = 0.8)}


#8.b

rough_no7 = lny-fit
rough_no7 = rough_no7[-c(100,101,102,103,104,105,106)]
mod_ARMA11 = arima(rough_no7, order = c(1,0,1))

#forecast trend 

library(Hmisc)
row_old = 1:99
row_pred = c(100,101,102,103,104,105,106) 
trend_pred = approxExtrap(row_old, ff$trend, xout= row_pred)$y

season_pred = rep(ff$season, length.out = length(chicago$reciepts))[-(1:99)]

forecast = predict(mod_ARMA11, n.ahead = 7)
x_fc = forecast$pred

truepredicted = x_fc+trend_pred+season_pred
untransform_predict = truepredicted^10
{plot(c(100,101,102,103,104,105,106), chicago$reciepts[100:106], col = "red", main = "Observed and Predicted Values", xlab = "Time", ylab = "Receipts", ylim = c(0,900))
points(c(100,101,102,103,104,105,106),untransform_predict, col = "green")
legend(102, 700, legend = c("Observed", "Predicted"), col = c("red", "green"), pch = 1, cex = 0.8)}
```

```

