---
title: "Time Series FInal Project"
author: "Truc Le"
date: "3/8/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
chicago <- read.csv("chicago.csv")
library("forecast")
```

#I Introduction

  The goal of this report is to fit a time series model to the given data, to predict the 




```{r, echo=FALSE}
trndseas=function(y,seas,lam,degtrnd){

    
# requires the R-package 'pracma'
  
# fits  a trend plus seasonal for the "best" Box-Cox 
# transformation.
  
# input: y, observed series; seas, seasons
  
# input: lam, the grid of Box-Cox transformations (lambda values)
  
# input: degtrnd, degree of the polynomial trend, if
# degtrnd=0, then the fitted trend is constant.
  
# output:  coef, regression coefficients - the
# first degtrnd+1 values for the trend part and the
# rest associated with the seasonals
  
# output: fit, fitted y-values; res, residuals,
  
# output: trend, fitted trend; season, fitted seasonals
  
# output: rsq, adjusted r-square values for different lambda in the
  
# output: lamopt, the value of lambda (among those supplied 
# in the vector lam) at which r-square is maximum.

m=length(lam)
n=length(y)

# Part of design matrix for estimating trend
if(degtrnd>0) {
   tm=seq(1/n,1,by=1/n)
   x1=poly(tm,degree=degtrnd,raw=TRUE)
   x1=cbind(rep(1,n),x1)
   } else {
    x1=as.matrix(rep(1,n),ncol=1)
   }

# Part of design matrix for estimating seasonality
x2=NULL
if(seas>1){
sn=rep(1:seas,length.out=n)
x2=factor(sn,levels=unique(sn),ordered=TRUE)
x2=model.matrix(~x2-1)
m2=ncol(x2)
m21=m2-1
x2=x2[,1:m21]-matrix(rep(x2[,m2],m21),ncol=m21,nrow=nrow(x2),byrow=F)
}

x=cbind(x1,x2)  # design matrix

xx=t(x)%*%x
rsq=rep(1,m)
m1=ncol(x1)     #degtrnd+1
m11=m1+1
mx=ncol(x)      # degtrnd+1+seas-1

for(i in 1:m) {
  if (lam[i]==0) {
    yt=log(y)
  } else {
    yt=y^lam[i]
   }
  xy=t(x)%*%yt
  coef=solve(xx,xy)
  fit=x%*%coef
  res=yt-fit
  ssto=(n-1)*var(yt)
  sse=t(res)%*%res
  rsq[i]=1-((n-1)/(n-mx))*sse/ssto
  }

  ii=which.max(rsq)
  lamopt=lam[ii]
  if (lamopt==0) {
    yt=log(y)
  } else {
    yt=y^lamopt
   }
  xy=t(x)%*%yt
  coef=solve(xx,xy)
  fit=x%*%coef
  trnd=x1%*%coef[1:m1]
  season=NULL
  if(seas>1){
  season=c(coef[m11:mx],-sum(coef[m11:mx]))
  }
  res=yt-fit

  result=list(coef=coef,fitted=fit,trend=trnd,residual=res,season=season,rsq=rsq,lamopt=lamopt)
  return(result)
}
  
```

```{r, echo=FALSE}
#3/4/5
y<-  chicago$reciepts
tm<- 1:106
seas <- 7
lam=seq(-1,1,by=0.05)
ff=trndseas(chicago$reciepts,seas,lam,3)
rsq=ff$rsq
ff=trndseas(chicago$reciepts,seas,0.1,3)
trend=ff$trend
season=ff$season
fit=ff$fit
tm=1:106
Day=1:7

plot(tm, y, type = "l",ylab="Daily Average Reciepts per Theatre",xlab="Time", main="Original Average Reciepts versus Time")



par(mfrow=c(2,2))
plot(lam,rsq,type="l",xlab="Lambda",ylab="R-sq",main="Average Ticket sales: R-square")

#fitted 
{plot.ts(y^0.1,ylab="",main='Plot: y^0.1,fit')
points(tm,fit,type='l',lty=2, col="red")
legend(175,0.070, c("data","fit"), lty=c(1,1,2))}

#trend line 
{plot.ts(y^0.1,ylab="",main='Plot: y^0.1, trend')
points(tm,trend,type='l', col="purple")
legend(175,0.070, c("data","trend"), lty=c(1,1,2))}

plot(Day,season,type='l',ylab='Seasonals',main='Seasonals for 1/y^0.1')


#transformed
{
lny <-(y)^0.1
plot(tm, lny, type = "l", lty = 1, xlab = "Time", ylab = "power of 0.1 daily average reciepts per theatre",main = "power of 0.1 daily average reciepts per theatre versus time")
points(tm, fit, type = "l", lty = 2, col = "blue")
legend("topleft", "fitted values", lty = 2, col = "blue")
}


plot(lny-fit, type = "l", xlab = "Time", ylab = "Residuals", main = "Rough part")


#6 
acf(lny-fit) 
pacf(lny-fit)

#7
a<-auto.arima(xhat, stepwise = F, approximation = F, trace= TRUE, ic = "aicc", max.order = 10)

mod_ARMA<- arima(y^0.1-fit, order =c(1,0,1))
mod_ARMA$coef
mod_ARMA$var.coef
mod_ARMA$sigma2
res <- mod_ARMA$residuals
ts.plot(res)

acf(res)
hist(res)

qqnorm(res);qqline(res)


#8

specselect=function(y,kmax)
  {
  ii=spec.pgram(y,log="no",plot=FALSE)
  ii=ii$spec
  cc=norm(as.matrix(ii),type="F")^2
  ctr=rep(1,kmax) ###criterion function
  for(k in 1:kmax) 
    {
    ss=2*k+1; kk=1/(2*k)
    ff=spec.pgram(y,spans=ss,log="no",plot=FALSE)
    fspec=ff$spec
    ctr[k]=norm(as.matrix(ii-fspec),type="F")^2+kk*cc
  }
  kopt=which.min(ctr)
  result=list(ctr=ctr,kopt=kopt)
  return(result)
}

specselect(lny-fit,18)


library(astsa)
coef.ar <- mod_ARMA$coef[1]
coef.ma <- mod_ARMA$coef[2]
sigma2 <- mod_ARMA$sigma2
mod_spec <-arma.spec(ar=coef.ar, ma=coef.ma, var.noise=sigma2, log='no')
plot(mod_spec$freq, mod_spec$spec, type='l', xlab='Frequency', ylab='')


#8.a
{arma.spec(ar=coef.ar, ma=coef.ma,var.noise = sigma2, log = "no",main="Spectral Density and Smooth Periodogram")
smooth<-spec.pgram(lny-fit, log = "no", spans = 11, main="", xlab="", ylab="", plot=F )
lines(smooth$freq, smooth$spec, col = "green")
legend(0.3, 0.018, legend = c("Spectral", "Smoothed"), col = c("black", "green"), lty = 1, cex = 0.8)}


#8.b

rough_no7 = lny-fit
rough_no7 = rough_no7[-c(100,101,102,103,104,105,106)]
mod_ARMA11 = arima(rough_no7, order = c(1,0,1))

#forecast trend 

library(Hmisc)
row_old = 1:99
row_pred = c(100,101,102,103,104,105,106) 
trend_pred = approxExtrap(row_old, ff$trend, xout= row_pred)$y

season_pred = rep(ff$season, length.out = length(chicago$reciepts))[-(1:99)]

forecast = predict(mod_ARMA11, n.ahead = 7)
x_fc = forecast$pred

truepredicted = x_fc+trend_pred+season_pred
untransform_predict = truepredicted^10
{plot(c(100,101,102,103,104,105,106), chicago$reciepts[100:106], col = "red", main = "Observed and Predicted Values", xlab = "Time", ylab = "Receipts", ylim = c(0,900))
points(c(100,101,102,103,104,105,106),untransform_predict, col = "green")
legend(102, 700, legend = c("Observed", "Predicted"), col = c("red", "green"), pch = 1, cex = 0.8)}
```

```

